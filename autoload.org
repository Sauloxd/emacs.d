#+TITLE: Utils
#+AUTHOR: Florian Schrödl (floscr)
#+PROPERTY: header-args :tangle yes
#+STARTUP: org-startup-folded: showall
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* Required Packages

Packages and utilities needed for this config.

- [[https://github.com/magnars/dash.el][magnars/dash.el: List Manipulation]]
- [[https://github.com/magnars/s.el][magnars/s.el: String Manipulation]]

#+BEGIN_SRC elisp
(require 'dash)
(require 's)
(require 'f)
#+END_SRC

* Macros
** Aliases

#+BEGIN_SRC elisp
;;;###autoload
(defalias 'λ 'lambda)
#+END_SRC

** Template Literals
:PROPERTIES:
:SOURCE:   https://gist.github.com/cbowdon/012d623920bd28453bf8
:END:

#+BEGIN_SRC elisp :tangle no
(template "2 = <<(+ 1 1)>>")
#+END_SRC

#+RESULTS:
: 2 = 2

#+BEGIN_SRC elisp
;;;###autoload
(defmacro template (text)
  "Template literals"
  (let ((pattern "<<\\(.*?\\)>>"))
    ;; The regexp matches anything between delimiters, non-greedily
    (with-temp-buffer
      (save-excursion (insert text))
      (let ((matches '()))
        (while (re-search-forward pattern nil t)
          (push (match-string 1) matches)
          (replace-match "%s" t t))
        `(format ,(buffer-string) ,@(reverse (mapcar 'read matches)))))))
#+END_SRC

* General Utils
** Kill and Message

#+BEGIN_SRC elisp
(defun copy-message (x)
  "Executes kill-new but with a message log side effect."
  (kill-new x)
  (message "Copied to clipboard: %s" x))
#+END_SRC

** Run current file
:PROPERTIES:
:SOURCE:   http://ergoemacs.org/emacs/emacs.html
:END:

#+BEGIN_SRC elisp
(defun run-current-file ()
  "Execute or compile the current file.
For example, if the current buffer is the file x.pl,
then it'll call “perl x.pl” in a shell.
The file can be php, perl, python, ruby, javascript, bash, ocaml, vb, elisp.
File suffix is used to determine what program to run.

If the file is modified, ask if you want to save first. (This command always run the saved version.)

If the file is emacs lisp, run the byte compiled version if exist."
  (interactive)
  (let (suffixMap fName fSuffix progName cmdStr)

    ;; a keyed list of file suffix to comand-line program path/name
    (setq suffixMap
          '(("php" . "php")
            ;; ("coffee" . "coffee -p")
            ("pl" . "perl")
            ("py" . "python")
            ("rb" . "ruby")
            ("js" . "node")             ; node.js
            ("sh" . "bash")
            ("ml" . "ocaml")
            ("vbs" . "cscript")))
    (setq fName (buffer-file-name))
    (setq fSuffix (file-name-extension fName))
    (setq progName (cdr (assoc fSuffix suffixMap)))
    (setq cmdStr (concat progName " \""   fName "\""))

    (when (buffer-modified-p)
      (progn
        (when (y-or-n-p "Buffer modified. Do you want to save first?")
          (save-buffer))))

    (if (string-equal fSuffix "el") ; special case for emacs lisp
        (progn
          (load (file-name-sans-extension fName)))
      (if progName
          (progn
            (message "Running…")
            ;; (message progName)
            (shell-command cmdStr "*run-current-file output*"))
        (message "No recognized program file suffix for this file.")))))
#+END_SRC

** Shuffle List
:PROPERTIES:
:SOURCE:   [[http://kitchingroup.cheme.cmu.edu/blog/2014/09/06/Randomize-a-list-in-Emacs/][Randomize a list in Emacs]]
:END:

#+BEGIN_SRC elisp
(defun swap-list-items (LIST el1 el2)
  "in LIST swap indices EL1 and EL2 in place"
  (let ((tmp (elt LIST el1)))
    (setf (elt LIST el1) (elt LIST el2))
    (setf (elt LIST el2) tmp)))

(defun -shuffle (LIST)
  "Shuffle the elements in LIST.
shuffling is done in place."
  (loop for i in (reverse (number-sequence 1 (1- (length LIST))))
        do (let ((j (random (+ i 1))))
             (swap-list-items LIST i j)))
  LIST)
#+END_SRC
** Eval and Replace sexp
:PROPERTIES:
:SOURCE:   https://emacsredux.com/blog/2013/06/21/eval-and-replace/
:END:

#+BEGIN_SRC elisp
(defun eval-and-replace-sexp ()
  "Replace the preceding sexp with its value."
  (interactive)
  (right-char) ;; Fix for normal mode
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))
#+END_SRC

** Buffer
*** Check current line for regex

#+BEGIN_SRC elisp
;;;###autoload
(defun buf-line-has (regexp)
  "Check for REGEXP at current line."
  (save-excursion
    (goto-char (point-at-bol))
    (search-forward-regexp regexp (point-at-eol) t)))
#+END_SRC
** Async Command No Window
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/a/47910509/2298462][How to avoid pop-up of *Async Shell Command* buffer in Emacs?]]
:END:

Prevent ~async-shell-command~ displaying a popup or a buffer.

#+BEGIN_SRC elisp
(defun async-shell-command-no-window (command)
  "Execute async command without showing the result buffer."
  (interactive)
  (let ((display-buffer-alist (list (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))))
    (async-shell-command command)))
#+END_SRC
* Window Utils

#+BEGIN_SRC elisp
 (setq wmctrl:window-list-re
  "^\\(0x[0-9a-f]+\\)  \\([0-9]+\\) \\([^ ]+\\)\\.\\([^ ]+\\) +\\([a-z]*\\) \\(.*\\)$")

(defun +wm/match-wm-string (x)
  (-let* ((xs (-drop 1 (s-match wmctrl:window-list-re x)))
          (pid (downcase (nth 0 xs)))
          (monitor (nth 1 xs))
          (process (nth 2 xs))
          (process-title (nth 3 xs))
          (user (nth 4 xs))
          (title (nth 5 xs)))
    (list
     :pid pid
     :monitor monitor
     :process process
     :process-title process-title
     :user user
     :title title)))

(defun +wm/list-windows ()
  "List X windows"
  (->> (shell-command-to-string "wmctrl -lx")
       (s-split "\n")
       (-drop-last 1)
       (-map #'+wm/match-wm-string)))

(defun +wm/last-window-id ()
  (--> (shell-command-to-string "bspc query -N -n last")
       s-trim
       downcase))

(defun +wm/last-window ()
  (let ((last-id (+wm/last-window-id))
        (windows (+wm/list-windows)))
    (--first (string= (plist-get it ':pid) last-id) windows)))

(setq wmctrl:chrome-window-title-re "^\\(.*\\) :: \\(.*\\) - Chromium$")

(defun +wm/last-chrome-window-org-link ()
  (-some--> (+wm/last-window)
    (plist-get it ':title)
    (s-match wmctrl:chrome-window-title-re it)
    (let ((title (nth 1 it))
          (url (nth 2 it)))
      (template "[[<<url>>][<<title>>]]"))))
#+END_SRC

* Functional Utils
** Noop

#+BEGIN_SRC elisp
(defun noop (&optional args) nil)
#+END_SRC

** Tap

Run a side effect ~fn~ on the initial input ~x~.
But Return the original input ~x~.

#+BEGIN_SRC elisp
(defun -tap (fn x)
  "Function docstring"
  (funcall fn x)
  x)

(defmacro --tap (fn it)
  "Anaphoric form of `-tap'."
  `(-tap (lambda (it) ,fn) ,it))
#+END_SRC

** Log

Log the current input without breaking the pipe.

#+BEGIN_SRC elisp
(defun -log (x)
  "Function docstring"
  (--tap (message "%s" it) x))
#+END_SRC

** When Forward

#+BEGIN_SRC elisp
(defun -when-id (when? x)
  "When a condition is t return the identity, otherwise return nil."
  (interactive)
  (if when? x nil))
#+END_SRC
* UI
#+BEGIN_SRC elisp
(defun +ui/get-display-dpi (&optional display)
  "Get the DPI of DISPLAY.
DISPLAY is a display name, frame or terminal, as in
`display-monitor-attributes-list'."
  (cl-flet ((pyth (lambda (w h)
                    (sqrt (+ (* w w)
                             (* h h)))))
            (mm2in (lambda (mm)
                     (/ mm 25.4))))
    (let* ((atts (frame-monitor-attributes))
           (pix-w (cl-fourth (assoc 'geometry atts)))
           (pix-h (cl-fifth (assoc 'geometry atts)))
           (pix-d (pyth pix-w pix-h))
           (mm-w (cl-second (assoc 'mm-size atts)))
           (mm-h (cl-third (assoc 'mm-size atts)))
           (mm-d (pyth mm-w mm-h)))
      (/ pix-d (mm2in mm-d)))))

(defun +ui/adjust-font (size line-space &optional font-family)
  (let* ((font-family (or font-family)))
    (setq-default line-spacing line-space)
    (setq-default doom-font (font-spec :family font-family :size size))
    (setq-default doom--font-scale nil)
    (set-frame-font doom-font 'keep-size t)
    (doom/reload-font)
    (run-hooks 'after-setting-font-hook)))

(defun +ui/active-display-name ()
  (interactive)
  (-some-->
   (shell-command-to-string "xrandr | grep \"connected primary\"")
   (s-match "^\\w+" it)
   car))

(defun +ui|adjust-ui-to-display ()
  "Adjust the UI to the current attached display."
  (interactive)
  (cond
   ((string= system-name "Florians-iMac.local")
    (+ui/adjust-font 14 10 "Menlo"))
   ((string= system-name "thinknix")
    (if (string= (+ui/active-display-name) "eDP1")
        ;; Internal Screen
        (+ui/adjust-font 15 7 "Fira Code")
      ;; HiDPI External
      (+ui/adjust-font 18 9 "Fira Code")))
   ((string= system-name "Florians-MacBook-Air.local")
    (+ui/adjust-font 14 10 "Menlo"))))
#+END_SRC
