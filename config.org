#+TITLE: Emacs Doom configuration
#+AUTHOR: Florian Schrödl (floscr)
#+PROPERTY: header-args :tangle yes
#+STARTUP: org-startup-folded: showall
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* Configuration
** External Files
*** Load additional packages

~straight.el~ doesn't accept EmacsWiki as a source, so I'm loading them manually.

#+BEGIN_SRC elisp
(add-to-list 'load-path "~/.config/doom/packages")
(add-to-list 'load-path "~/.config/doom/packages/om")
#+END_SRC

*** Secrets

Config files that I don't want to share with the world.

They will be stored in here:

#+BEGIN_SRC elisp
(setq my-secrets-config-file "~/.config/secrets.el")
#+END_SRC

And I will load them on system start:

#+BEGIN_SRC elisp
(defun my-load-secrets-config ()
  (if-let ((file (if (file-exists-p my-secrets-config-file) my-secrets-config-file)))
      (load-library my-secrets-config-file)))

(my-load-secrets-config)
#+END_SRC

** Essentials
*** Safe Local Variables

Variables that I want to safely set from ~.dir-locals~ files.

#+BEGIN_SRC elisp
(put '+file-templates-dir 'safe-local-variable #'stringp)
#+END_SRC

*** Directories

#+BEGIN_SRC elisp
(defcustom downloads-dir "~/Downloads/"
  "Downloads Directory"
  :type 'string)

(defcustom screenshot-dir "~/Pictures/Screenshots"
  "Screenshots Directory"
  :type 'string)
#+END_SRC

** Utilities
*** Toggle Window Dedicated
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/2189/how-can-i-prevent-a-command-from-using-specific-windows][buffers - How can I prevent a command from using specific windows? - Emacs Stack Exchange]]
:END:

Lock a window so the buffer can't be changed or it cant be deleted.

#+BEGIN_SRC elisp
(defun toggle-window-dedicated ()
  "Control whether or not Emacs is allowed to display another
buffer in current window."
  (interactive)
  (message
   (if (let (window (get-buffer-window (current-buffer)))
         (set-window-dedicated-p window (not (window-dedicated-p window))))
       "%s: Window locked!"
     "%s: Window unlocked!")
   (current-buffer)))
#+END_SRC
*** File Utilities
**** Get the latest file in directory
:PROPERTIES:
:SOURCE:   https://stackoverflow.com/a/30886283
:END:

Get the last created file in a directory.
Used for getting the last screenshot to attach to an [[file:modules/private/org/config.org::*Screenshot][org document]].

#+BEGIN_SRC elisp
(defun +file/latest-file-in-dir (path)
  (let ((e (f-entries path)))
    (car (sort e (lambda (a b)
                   (not (time-less-p (file-timestamp a)
                                     (file-timestamp b))))))))

(defun file-timestamp (f) (let ((attrs (file-attributes f))) (nth 5 attrs)))
#+END_SRC

*** Hydras
**** Hydra Expand Region
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/also27/second_trial_for_a_weekly_tipstricksetc_thread/efi7pbj/
:END:

Expand region using a hydra.
Double press ~v~ to enable.

#+BEGIN_SRC elisp
(defhydra hydra-expand-region ()
   "region: "
   ("f" er/mark-defun "defun")
   ("v" er/expand-region "expand")
   ("V" er/contract-region "contract"))

(evil-define-key 'visual 'global (kbd "v") #'hydra-expand-region/body)
#+END_SRC
** UI
*** Frame padding

#+BEGIN_SRC elisp
(set-frame-parameter nil 'internal-border-width 15)
#+END_SRC

*** System specific window modifications

Resize the window font size etc according to the system.
This will be disabled in terminal mode.

#+BEGIN_SRC elisp
(when (display-graphic-p)
#+END_SRC

#+BEGIN_SRC elisp
(defun +ui/get-display-dpi (&optional display)
  "Get the DPI of DISPLAY.
DISPLAY is a display name, frame or terminal, as in
`display-monitor-attributes-list'."
  (cl-flet ((pyth (lambda (w h)
                    (sqrt (+ (* w w)
                             (* h h)))))
            (mm2in (lambda (mm)
                     (/ mm 25.4))))
    (let* ((atts (frame-monitor-attributes))
           (pix-w (cl-fourth (assoc 'geometry atts)))
           (pix-h (cl-fifth (assoc 'geometry atts)))
           (pix-d (pyth pix-w pix-h))
           (mm-w (cl-second (assoc 'mm-size atts)))
           (mm-h (cl-third (assoc 'mm-size atts)))
           (mm-d (pyth mm-w mm-h)))
      (/ pix-d (mm2in mm-d)))))

(defun +ui/adjust-font (size line-space &optional font-family)
  (let* ((font-family (or font-family)))
    (setq-default line-spacing line-space)
    (setq-default doom-font (font-spec :family font-family :size size))
    (set-frame-font doom-font 'keep-size t)
    (message "reload frame")
    (doom/reload-font)))

(defun +ui|adjust-ui-to-display ()
  "Adjust the UI to the current attached display."
  (interactive)
  (cond
   ((string= system-name "Florians-iMac.local")
    (+ui/adjust-font 14 10 "Menlo"))
   ((string= system-name "thinknix")
    (if (eq (round (+ui/get-display-dpi)) 158)
        ;; Internal Screen
        (+ui/adjust-font 15 7)
      ;; HiDPI External
      (+ui/adjust-font 18 9)))
   ((string= system-name "Florians-MacBook-Air.local")
    (+ui/adjust-font 14 10 "Menlo"))))

(+ui|adjust-ui-to-display)
#+END_SRC

#+BEGIN_SRC elisp
)
#+END_SRC

*** Theme Toggle

Toggle between a light and a dak theme.
Bound to ~SPC t t~.

#+BEGIN_SRC elisp
(defconst light-theme 'doom-one)
(defconst dark-theme  'doom-one-light)

(defun +doom|toggle-theme ()
  "Toggle between light and dark themes."
  (interactive)
  (cond ((eq doom-theme dark-theme)
         (message "Toggling to light-theme: %s" light-theme)
         (setq doom-theme light-theme)
         (doom/reload-theme))
        ((eq doom-theme light-theme)
         (message "Toggling to dark-theme: %s" dark-theme)
         (setq doom-theme dark-theme)
         (doom/reload-theme))
        (t (message "Toggling theme is not possible. Theme is not currently light-theme (%s) or dark-theme (%s)." light-theme dark-theme))))
#+END_SRC

*** Theme Modifications

#+BEGIN_SRC elisp
(add-hook 'doom-load-theme-hook #'*doom-themes-custom-set-faces)
#+END_SRC

**** Function Start

#+BEGIN_SRC elisp
(defun *doom-themes-custom-set-faces ()
  (set-face-attribute 'fringe nil
                      :foreground (face-background 'default)
                      :background (face-background 'default))
  (custom-set-faces!
#+END_SRC

**** Dired Output

Remove the rainbow colors from dired.

#+BEGIN_SRC elisp
'(diredfl-read-priv :foreground "#80899E")
'(diredfl-write-priv :foreground "#80899E")
'(diredfl-exec-priv :foreground "#80899E")
'(diredfl-other-priv :foreground "#80899E")

'(all-the-icons-dired-dir-face :foreground "#80899E")

'(diredfl-dir-priv :foreground "#282C34")
'(diredfl-k-modified :foreground "#FF8E90")

'(diredfl-number :foreground "#80899E")
'(diredfl-date-time :foreground "#49505F")
`(diredfl-dir-name :foreground "#2DADF2")
#+END_SRC

**** Mu4E

Switch the highlight.

#+BEGIN_SRC elisp
'(mu4e-highlight-face :inherit mu4e-unread-face)
#+END_SRC

**** Function End

#+BEGIN_SRC elisp
))
#+END_SRC

*** Scrolloff

Start scrolling X lines before the end of a screen.
Disable for certain modes (terminal & ivy) where the window is to small.

#+BEGIN_SRC elisp
(setq
 scroll-conservatively 10
 scroll-margin 10)

(add-hook 'term-mode-hook (λ! (setq-local scroll-margin 0)))
(add-hook 'ivy-mode-hook (λ! (setq-local scroll-margin 0)))
#+END_SRC

*** Line Spacing

Change and reset line-spacing for all buffers.

#+BEGIN_SRC elisp
(defvar +ui-default-line-spacing line-spacing)
(defvar +ui-default-line-spacing-increment 1)
(defvar +ui-big-line-spacing-increment 10)

(defun +ui/set-line-spacing (&optional increment)
  "Set the line spacing
When no line spacing is given is the default-line-spacing"
  (setq-default line-spacing (+ (or increment +ui-default-line-spacing-increment) line-spacing)))

(defun +ui|reset-line-spacing ()
  (interactive)
  (setq-default line-spacing +ui-default-line-spacing))

(defun +ui|increase-line-spacing ()
  (interactive)
  (+ui/set-line-spacing))

(defun +ui|decrease-line-spacing ()
  (interactive)
  (+ui/set-line-spacing (- +ui-default-line-spacing-increment)))

(defun +ui|increase-line-spacing-big ()
  (interactive)
  (+ui/set-line-spacing +ui-big-line-spacing-increment))

(defun +ui|decrease-line-spacing-big ()
  (interactive)
  (+ui/set-line-spacing (- +ui-big-line-spacing-increment)))

(evil-define-key 'normal 'global (kbd "]z") #'+line-spacing/step/body)

;;;###autoload (autoload '+common-lisp/macrostep/body "lang/common-lisp/autoload/hydras" nil nil)
(defhydra +line-spacing/step (:exit nil :hint nil :foreign-keys run :color pink)
  "
Macro Expansion
^^Definitions                           ^^Compiler Notes             ^^Stickers
^^^^^^─────────────────────────────────────────────────────────────────────────────────────
[_r_] Reset
[_]_] Expand
[_[_] Collapse
[_}_] Expand Big
[_{_] Collapse Big
"
  ("r" +ui|reset-line-spacing)
  ("]" +ui|increase-line-spacing)
  ("[" +ui|decrease-line-spacing)
  ("}" +ui|increase-line-spacing-big)
  ("{" +ui|decrease-line-spacing-big)
  ("q" nil "cancel" :color blue))
#+END_SRC

#+RESULTS:
: +line-spacing/step/body

*** Popups

#+BEGIN_SRC elisp
(after! org
  (set-popup-rule! "^\\*Org Agenda" :side 'right :size 0.55 :select t :modeline t :ttl nil :quit nil)
  (set-popup-rule! "^\\*Org Src" :ignore t)
  (set-popup-rule! "^\\*Org QL Search" :side 'bottom :size 0.5 :select t :modeline t :ttl nil))

(after! image-dired
  (set-popup-rule! "^\\*image-dired" :size 0.38 :select t))

(after! helm
  (set-popup-rule! "^\\*helm" :vslot -100 :size 0.32 :ttl nil))

(set-popup-rule! "^\\*nodejs" :side 'right :size 0.55 :select t :modeline t :ttl nil :quit nil)

(set-popup-rule! "^\\*helpful command" :side 'right :size 0.5 :select t :modeline t :ttl nil :quit nil)
#+END_SRC

*** (Visual) Fill Column

#+BEGIN_SRC elisp :tangle no
(setq-default fill-column 110)
(setq fill-column 110)
(setq visual-fill-column-width fill-column)

(setq visual-fill-column-center-text t
      visual-fill-column-width fill-column)
#+END_SRC

*** Disable trailing whitespace warning

#+BEGIN_SRC elisp :tangle no
(setq-hook! 'prog-mode-hook show-trailing-whitespace nil)
#+END_SRC

*** Fix underline

Draw the underline at the bottom of the text, not at the end of line-spacing.

#+BEGIN_SRC elisp
(setq x-underline-at-descent-line nil)
#+END_SRC

** Custom Packages
*** Math on Numbers

Run a simple mathematic operation on a number under the cursor.

#+BEGIN_SRC elisp
(defun math-on-number (f &optional num)
  "Read user input and apply with function f to the number at point"
  (let* ((x (thing-at-point 'number))
         (arithmetic-symbol (pcase f
                              ('+ "+")
                              ('- "-")
                              ('/ "/")
                              ('* "*")
                              (_ (error "Unknown function %s" f))))
         (readline (concat (number-to-string x) " " arithmetic-symbol " "))
         (y (or num (read-number readline)))
         (result (funcall f x y))
         (bounds (bounds-of-thing-at-point 'evil-WORD)))
    (delete-region (car bounds) (cdr bounds))
    (insert (format "%.02f" result))))

(defun +math|add-to-number ()
  (interactive)
  (math-on-number '+))

(defun +math|subtract-from-number ()
  (interactive)
  (math-on-number '-))

(defun +math|subtract-maran-vegan ()
  (interactive)
  (math-on-number '- 8.60))

(defun +math|divide-by-number ()
  (interactive)
  (math-on-number '/))

(defun +math|multiply-by-number ()
  (interactive)
  (math-on-number '*))
#+END_SRC
*** Birthday Messsage

#+BEGIN_SRC elisp
(setq birthday-slack-emojis '("🍰" "🎂" "🎉" "🎈" "🎁"))

(defun birthday-msg (name &optional emojis)
  "Creates birthday string"
  (let ((emojis (or emojis (--> birthday-slack-emojis
                               (-shuffle it)
                               (-take 3 it)
                               (string-join it " ")))))
    (template "<<(reverse emojis)>> !! Happy Birthday <<name>> !! <<emojis>>")))

(defun birthday-msg|copy ()
  "Copies birthday string"
  (interactive)
  (--> (read-string "Name: ")
       (birthday-msg it)
       (copy-message it)))
#+END_SRC

*** Guitar Timer

I log my guitar learning into an org file that is formated like this.

#+BEGIN_SRC org :tangle no
| Date                   | Progression | Progressions |
| [2019-07-28 Sun 22:26] | A-D         |           12 |
#+END_SRC

This function starts a timer and after 60 seconds,
plays a sound and prompts me to insert my count.

#+BEGIN_SRC elisp

(defvar +guitar-timer-status-paused)
(defvar +guitar-timer-status-ticking)
(setq +guitar-timer-status '+guitar-timer-status-paused
      +guitar-timer-time nil)

(defface +guitar-timer-face
  '((t . (:height 2.5)))
  "The timer face")

(setq +guitar-chords '("A" "D" "E")
      +guitar-beep  "/System/Library/Sounds/Glass.aiff"
      +guitar-timer-duration 80
      +guitar-timer-buffer-name "*Guitar Timer")

(defun +guitar/chord-combinations ()
  (-reduce-from
        (lambda (acc cur)
          (--> +guitar-chords
               (-map (lambda (x)
                       (unless (or (eq cur x) (-contains? acc (concat x "-" cur)))
                         (concat cur "-" x))) it)
               (-snoc acc it)
               -flatten))
        '() +guitar-chords))

(define-minor-mode +guitar-timer-mode
  "A little timer.")
  ;; nil
  ;; "Guitar Timer"
  ;; +guitar-timer-mode-map)


;; (defvar +guitar-timer-mode-map (make-keymap) "Timer Key Map")

;; (map! :map +guitar-timer-mode-map
;;       :mgnvi "q" '+guitar|quit
;;       :mgnvi [escape] '+guitar|quit)

(defun +guitar/read-timer ()
  (start-process-shell-command "Guitar Timer Done" nil (template "afplay <<+guitar-beep>>"))
  (let ((amount (read-string "Count: ")))
    (other-window 1)
    (insert amount)
    (org-cycle)
    (forward-line -1)
    (evil-normal-state)))

  ;; (let ((amount (read-string "Count: "))
  ;;       (timestamp (format-time-string "[%F %a %H:%M]" (current-time)))
  ;;       (progression (template "<<from>>-<<to>>")))
  ;;   (save-excursion
  ;;     (evil-insert-newline-above)
  ;;     (insert (concat "| " (s-join " | " (list timestamp progression amount))))
  ;;     (call-interactively #'org-cycle))
  ;;   (play-sound-file +guitar-beep)))

(defun +guitar|start-timer (&optional from to)
  "Start a timer for a chord progression."
  (interactive)
  (let ((from (or from (ivy-read "From: " +guitar-chords)))
        (to (or to (ivy-read "To: " +guitar-chords))))
    (insert from)
    (org-cycle)
    (insert to)
    (org-cycle)
    (+guitar/create-timer-buffer #'+guitar/read-timer)))

(defun +guitar|resume-timer ()
  (interactive)
  (if-let ((buffer (get-buffer +guitar-timer-buffer-name)))
      (progn
        (setq +guitar-timer-status '+guitar-timer-status-ticking)
        (+guitar/tick-timer-buffer buffer +guitar-timer-time))
    (message "No guitar timer buffer!")))

(defun +guitar|pause-timer ()
  (interactive)
  (setq +guitar-timer-status '+guitar-timer-status-paused))

(defun +guitar|quit ()
  (interactive)
  (setq +guitar-timer-status '+guitar-timer-status-paused)
  (if-let ((buffer (get-buffer +guitar-timer-buffer-name)))
      (kill-buffer buffer)))

(defun +guitar/tick-timer-buffer (buffer time &optional callback)
  (when (and (get-buffer buffer)
             (eq +guitar-timer-status '+guitar-timer-status-ticking))
    (with-current-buffer buffer
      (erase-buffer)
      (let* ((new-time (- time 1))
             (time-string (format-time-string "%M:%S" (seconds-to-time new-time) t)))
        (put-text-property 0 (length time-string) 'face '+guitar-timer-face time-string)
        (insert time-string)
        (if (> new-time 0)
            (progn
              (setq +guitar-timer-time new-time)
              (run-with-timer 1 nil #'+guitar/tick-timer-buffer buffer new-time callback))
          (if callback
              (funcall callback)))))))

(defun +guitar/create-timer-buffer (&optional callback)
  (let ((buffer (generate-new-buffer +guitar-timer-buffer-name)))
    (pop-to-buffer buffer)
    (with-current-buffer buffer
      (setq +guitar-timer-status '+guitar-timer-status-ticking)
      (let ((inhibit-read-only t))
        (+guitar-timer-mode)
        (erase-buffer)
        (insert (number-to-string +guitar-timer-duration))
        (+guitar/tick-timer-buffer buffer (+ +guitar-timer-duration 1) callback)))))

(defun +guitar|start ()
  (interactive)
  (+guitar/create-timer-buffer '(lambda () (start-process-shell-command "Guitar Timer Done" nil (template "afplay <<+guitar-beep>>")))))

(set-popup-rule! "^\\*Guitar" :quit nil :height 4 :select nil :transient t)

;; (defun promise-sequence (xs)
;;   (if-let ((current (car xs)))
;;     (funcall current (lambda () (promise-sequence (cdr xs))))))

;; (defun +guitar/foo ()
;;   "Hello"
;;   (unless (get-buffer +guitar-timer-buffer-name)
;;     (+guitar/create-timer-buffer '(lambda () (start-process-shell-command "Guitar Timer Done" nil (template "afplay <<+guitar-beep>>")))))
;;   ())

(defun +guitar|start-progressions (&optional from to)
  "Start progression timers"
  (interactive)
  (let ((buffer-name (concat org-ql-view-buffer-name-prefix " (heading Timer)*")))
    (org-ql-search (f-join org-directory "Main/music.org") '(heading "Timer"))
    (with-current-buffer buffer-name
      (org-agenda-switch-to t))
    (kill-buffer buffer-name)
    (with-current-buffer "music.org"
      (search-forward-regexp "Date")
      (forward-line 2)
      (call-interactively #'evil-org-open-above)
      (let ((date (format-time-string "[%Y-%m-%d %a %H:%M]" (current-time))))
        (insert date)
        (org-cycle)
        (+guitar|start-timer from to)))))
#+END_SRC
** Package Config
*** IRC

#+BEGIN_SRC elisp
(set-irc-server! "chat.freenode.net"
  `(:tls t
    :port 6697
    :nick "floscr"
    :sasl-username ,(+pass-get-user "Irc/freenode.net")
    :sasl-password (lambda (&rest _) (+pass-get-secret "Irc/freenode.net"))
    :channels ("#emacs" "#nixos")))
#+End_SRC

*** Calendar

**** Conf
***** Calendars

Emacs comes with a lot of custom calendars that I don't want.
This is mostly copied from [[https://thenybble.de/projects/german-emacs-calendar.html][How to set up a german emacs calendar]].

****** General Holidays

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq general-holidays
        '((holiday-fixed 1 1 "New Years")
          (holiday-fixed 5 1 "1st Mai"))))
#+END_SRC

****** Austrian Holidays

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq austrian-holidays
        `((holiday-fixed 1 6 "Heilige drei Könige")
          (holiday-fixed 5 1 "Staatsfeiertag")
          (holiday-fixed 8 15 "Mariä Himmelfahrt")
          (holiday-fixed 10 26 "Nationalfeiertag")
          (holiday-fixed 11 1 "Allerheiligen")
          (holiday-fixed 12 8 "Mariä Empfängnis")
          (holiday-fixed 12 24 "Weihnachten")
          (holiday-fixed 12 25 "Christtag")
          (holiday-fixed 12 26 "Stefanitag")
          ;; variable
          (holiday-easter-etc -2 "Karfreitag")
          (holiday-easter-etc 0 "Ostersonntag")
          (holiday-easter-etc 1 "Ostermontag")
          (holiday-easter-etc 39 "Christi Himmelfahrt")
          (holiday-easter-etc 49 "Pfingstsonntag")
          (holiday-easter-etc 50 "Pfingstmontag")
          (holiday-easter-etc 60 "Fronleichnam"))))
#+END_SRC

****** Set calendars

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq calendar-holidays
        (append
          general-holidays
          austrian-holidays
          holiday-solar-holidays)))
#+END_SRC

***** General

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq calendar-week-start-day 1)
  (setq calendar-time-display-form
        '(24-hours ":" minutes (and time-zone (concat " (" time-zone ")"))))
  (setq calendar-abbrev-length 2))
#+END_SRC

*** Calc
**** Additional Units

#+BEGIN_SRC elisp
(setq math-additional-units '((GB "1024 * MiB" "Giga Byte")
                              (MB "1024 * KiB" "Mega Byte")
                              (KB "1024 * B" "Kilo Byte")
                              (B nil "Byte")))
#+END_SRC

*** Comint
**** Allow evil enter anywhere

Fix for comint mode, throwing an error when pressing enter in the middle of the line.

#+BEGIN_EXAMPLE
error in process filter: End of buffer
#+END_EXAMPLE

#+BEGIN_SRC elisp
(map!
 :after comint
 :map comint-mode-map
 :ni "RET" (λ! (comint-send-input nil t))
 :n "<C-backspace>" #'comint-clear-buffer)
#+END_SRC

*** Company
**** Config
***** Sort company by occurrence
:PROPERTIES:
:SOURCE:   [[https://github.com/company-mode/company-mode/issues/52][{Proposal} Improve company-dabbrev candidate ordering · Issue #52 · company-mode/company-mode]]
:END:

#+BEGIN_SRC elisp
(setq company-transformers '(company-sort-by-occurrence)
      company-idle-delay 0.5)
#+END_SRC

**** Functions
***** Company complete whole lines for all matching buffers

Complete a whole line with all lines from buffers matching the current major-mode.

#+BEGIN_SRC elisp
(defun +company:buffer-list-with-modes (modes)
  "Get all buffers that match MODES"
  (--filter
   (with-current-buffer it (-contains? (doom-enlist modes) major-mode))
   (buffer-list)))

(defun +company:buffer-list-with-major-mode ()
  "Get all buffers matching the current major-mode
Has built in aliases"
  (let ((javascript-modes (list 'rjsx-mode 'js2-mode)))
    (pcase major-mode
      ('rjsx-mode
       (+company:buffer-list-with-modes javascript-modes))
      ('js2-mode
       (+company:buffer-list-with-modes javascript-modes))
      (_
       (+company:buffer-list-with-modes major-mode)))))

(defun +company/whole-lines-all-buffers (command &optional arg &rest ignored)
  "`company-mode' completion backend that completes whole-lines, akin to vim's
C-x C-l."
  (interactive (list 'interactive))
  (require 'company)
  (pcase command
    (`interactive (company-begin-backend '+company/whole-lines-all-buffers))
    (`prefix      (company-grab-line "^[\t\s]*\\(.+\\)" 1))
    (`candidates
     (all-completions
      arg
      (funcall (-compose
                #'-uniq
                #'-flatten
                (lambda (xs)
                  (--map (with-current-buffer it
                           (split-string
                            (replace-regexp-in-string
                             "^[\t\s]+" ""
                             (buffer-substring-no-properties (point-min) (point-max)))
                            "\\(\r\n\\|[\n\r]\\)" t)) xs)))
               (+company:buffer-list-with-major-mode))))))
#+END_SRC

Bindings

#+BEGIN_SRC elisp
(map!
 (:prefix "C-x"
   :i "C-l" #'+company/whole-lines-all-buffers
   :i "C-." #'+company/whole-lines))
#+END_SRC

*** Dired
**** Config

#+BEGIN_SRC elisp
(use-package! dired
  :init
  (setq
    dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|\\.DS_Store$"))
#+END_SRC

***** Ignore .bs.js

#+BEGIN_SRC elisp
(use-package! dired-x
  :after dired
  :config
  (setq dired-omit-files
        (concat dired-omit-files
                ;; Reason Compiled Files
                "\\|\\.bs.js$")))
#+END_SRC

***** Auto Refresh
:PROPERTIES:
:SOURCE:   [[https://www.reddit.com/r/emacs/comments/1acg6q/how_to_configure_dired_to_update_instantly_when/][How to configure dired to update instantly when files/folders change? : emacs]]
:END:

Automatically revert dired buffers.

#+BEGIN_SRC elisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

***** Automatically create directories when moving/copying items
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/12994164/allow-dired-do-copy-and-dired-do-rename-to-create-new-dir-on-the-fly][emacs - Allow dired-do-copy and dired-do-rename to create new dir on the fly - Stack Overflow]]
:END:

#+BEGIN_SRC elisp
(after! dired
  (defadvice dired-mark-read-file-name (after rv:dired-create-dir-when-needed (prompt dir op-symbol arg files &optional default) activate)
    (when (member op-symbol '(copy move))
      (let ((directory-name (if (< 1 (length files))
                                ad-return-value
                              (file-name-directory ad-return-value))))
        (when (and (not (file-directory-p directory-name))
                   (y-or-n-p (format "directory %s doesn't exist, create it?" directory-name)))
          (make-directory directory-name t))))))
#+END_SRC

**** Functions
***** Kill all dired buffers with ~Q~

#+BEGIN_SRC elisp
(defun +dired|kill-dired-buffers ()
  "Kills all dired buffers
Dired creates a buffer for every directory which it visits
Which is fine since you can easily switch between visited buffers
But at some time I want to purge those buffers"
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))

(map! :after dired
      :map dired-mode-map
      :n "q" (λ! (kill-buffer))
      :n "Q" #'+dired|kill-dired-buffers)
#+END_SRC

***** Wdired Mode Switch

Stay in normal mode when switching to wdired

#+BEGIN_SRC elisp
(defun +dired|change-to-wdired-mode ()
  "Simple forward to wdired-change-to-wdired-mode, but staying in normal mode."
  (interactive)
  (wdired-change-to-wdired-mode)
  (evil-normal-state))
#+END_SRC

Map ~\~ to change to wdired mode, like text mode in maggit buffers.

#+BEGIN_SRC elisp
(map!
 :after dired
 :map dired-mode-map
 :n "\\" #'+dired|change-to-wdired-mode)
#+END_SRC

***** Use same window for copying/renaming with prefix

I've set ~dired-dwim-target~ to ~t~, so it uses the other window as the target destination.
I undo this option with the interactive prefix argument, which can be accessed via ~SPC ucopy R/U~.

#+BEGIN_SRC elisp
(defun +dired/dired-target-from-prefix (fn)
  (let ((dired-dwim-target (if (eq (prefix-numeric-value current-prefix-arg) 4) ;; Single C-u
                              nil
                            dired-dwim-target)))
      (call-interactively fn)))

(defun +dired|dired-do-copy (&optional arg)
  (interactive "P")
  (+dired/dired-target-from-prefix #'dired-do-copy))

(defun +dired|dired-do-rename (&optional arg)
  (interactive "P")
  (+dired/dired-target-from-prefix #'dired-do-rename))

(map! :after dired
      :map dired-mode-map
      :n "R" #'+dired|dired-do-rename
      :n "C" #'+dired|dired-do-copy)
#+END_SRC
***** Show Marked File Size
:PROPERTIES:
:SOURCE:   https://www.emacswiki.org/emacs/DiredGetFileSize
:END:

#+BEGIN_SRC elisp
 (defun dired-get-size ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (with-temp-buffer
      (apply 'call-process "du" nil t nil "-sch" files)
      (message
       "Size of all marked files: %s"
       (progn (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$") (match-string 1))))))
#+END_SRC

***** Open file externally
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/cgbpvl/opening_media_files_straight_from_gnu_emacs_dired/eufxc9j/
:END:

#+BEGIN_SRC elisp
(defun +dired|open-externally ()
  "Open marked dired file(s) at point with an external application."
  (interactive)
  (let ((file-list (dired-get-marked-files))
        (process-connection-type nil))
    (mapc
     (lambda (file-path)
       (start-process
          "" nil shell-file-name
          shell-command-switch
          (format "nohup 1>/dev/null 2>/dev/null xdg-open \"%s\" &"
                  (expand-file-name file-path))))
     file-list)))
#+END_SRC

**** Extensions
***** Dired Narrow

[[https://github.com/Fuco1/dired-hacks#dired-narrow][Dired Narrow]] allows narrowing a dired buffer to a subselection.
Widen can be restored with ~g~.

#+BEGIN_SRC elisp
(use-package! dired-narrow
  :after dired
  :config
  (bind-key "C-c C-n" #'dired-narrow))
#+END_SRC

***** Dired Subtree

#+BEGIN_SRC elisp
(use-package! dired-subtree
  :after dired
  :config
  (evil-define-key 'normal dired-mode-map
    (kbd "<tab>") (λ! () (dired-subtree-toggle)
                      ;; Fix for dired-all-the-icons not showing up
                      (dired-revert))
    (kbd "<backtab>") (λ! () (dired-subtree-cycle)
                          (dired-revert))
    (kbd "gh") 'dired-subtree-up))
#+END_SRC

***** Dired Filter

#+BEGIN_SRC elisp
(use-package! dired-filter
  :after dired
  :config
  (setq dired-filter-saved-filters
        (quote (("images"
                 (extension "jpg" "png" "gif"))
                ("media"
                 (extension "mp3" "mp4" "MP3" "MP4" "avi" "mpg" "flv" "ogg" "wmv" "mkv" "mov" "wma"))
                ("archives"
                 (extension "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
                ("documents"
                 (extension "doc" "docx" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub"))))))

#+END_SRC
**** Bindings

#+BEGIN_SRC elisp
(map! :after dired
      :map dired-mode-map
      :ng "<C-return>" '+dired|open-externally)
#+END_SRC

*** Eldoc

#+BEGIN_SRC elisp :tangle no
;; Always truncate ElDoc messages to one line. This prevents the echo
;; area from resizing itself unexpectedly when point is on a variable
;; with a multiline docstring.
(setq eldoc-echo-area-use-multiline-p nil)

;; Show ElDoc messages in the echo area immediately, instead of after
;; 1/2 a second.
(setq eldoc-idle-delay 0)

;; Disable eldoc mode
(global-eldoc-mode -1)
#+END_SRC

*** Eshell
**** Aliases

Custom eshell aliases.

#+BEGIN_SRC elisp
(setq +eshell-aliases
  '(("q"      "exit")
    ("f"      "find-file $1")
    ("bd"     "eshell-up $1")
    ("rg"     "rg --color=always $*")
    ("ag"     "ag --color=always $*")
    ("l"      "ls -lh")
    ("ll"     "ls -lah")
    ("gs"     "git status")
    ("groot"  "cd (projectile-project-root)")
    ("gc"     "git commit")
    ("grha"   "git reset --hard; git clean -f -d")
    ("clear"  "clear-scrollback")))
#+END_SRC

**** Syntax highlighted cat

#+BEGIN_SRC elisp
(defun +eshell/cat (file)
  "Like `cat' but output with Emacs syntax highlighting."
  (with-temp-buffer
    (insert-file-contents file)
    (let ((buffer-file-name file))
      (delay-mode-hooks
        (set-auto-mode)
        (if (fboundp 'font-lock-ensure)
            (font-lock-ensure)
          (with-no-warnings
            (font-lock-fontify-buffer)))))
    (buffer-string)))

(add-to-list '+eshell-aliases '("cat" "+eshell/cat $1"))
#+END_SRC

*** Evil-Snipe
**** Repeat snipe after further key press

#+BEGIN_SRC elisp
(after! evil-snipe
  (setq evil-snipe-repeat-keys t))
#+END_SRC

*** EWW Web Browser
**** Set the max page width

#+BEGIN_SRC elisp
(setq shr-width 120)
#+END_SRC

*** git-lens

#+BEGIN_SRC elisp
(use-package! git-lens
  :commands (git-lens))
#+END_SRC

*** Symex

#+BEGIN_SRC elisp
(use-package! symex
  :commands (symex-mode symex-mode-interface))
#+END_SRC

*** Indium

#+BEGIN_SRC elisp
(use-package! indium
  :commands indium-connect)
#+END_SRC

*** Impatient-Mode

Serves the current buffer live over http.

#+BEGIN_SRC elisp
(use-package! impatient-mode
  :commands impatient-mode)
#+END_SRC

*** Narrow To Defun Indirect

When narrowing to region or defun, make it in an indirect other window.

Source:
- [[./packages/narrow-indirect.el]]
- [[https://www.emacswiki.org/emacs/NarrowIndirect][EmacsWiki: Narrow Indirect]]

#+BEGIN_SRC elisp
(use-package! narrow-indirect
  :init
  (global-set-key (kbd "C-x n n") 'ni-narrow-to-region-indirect-other-window)
  (global-set-key (kbd "C-x n d") 'ni-narrow-to-defun-indirect-other-window))
#+END_SRC

*** Ivy / Swiper
**** Bindings

Adds general bindings to ivy.
~MOD + ↩~ will insert the current item and continue with a new instance of the same ivy buffer.
~CTRL + ↩~ will abort completion and insert the inserted text.

#+BEGIN_SRC elisp
(map!
 :after ivy
 :map ivy-minibuffer-map
  "<s-return>" 'ivy-call
  "<C-return>" 'ivy-immediate-done)
#+END_SRC

**** Counsel Project File Jump

#+BEGIN_SRC elisp
(defun +ivy/counsel-project-file-jump (x)
  "Jump to file in project"
  (interactive)
  (counsel-file-jump nil (f-join (projectile-project-root) x)))
#+END_SRC

**** Counsel Files

#+BEGIN_SRC elisp
(defun +ivy|search-buffers ()
  "Grep workspace buffers."
  (interactive)
  (-->
   (+workspace-buffer-list)
   (cl-remove-if-not #'buffer-file-name it)
   (-map #'buffer-file-name it)
   (-map #'shell-quote-argument it)
   (s-join " " it)
   (counsel-grep-files it)))

(defun counsel-grep-files (buffer-file-names)
  "Grep for a string in the file visited by the current buffer."
  (interactive)
  (counsel-require-program counsel-grep-base-command
   (setq counsel-grep-command
         (format counsel-grep-base-command "%s" buffer-file-names))
   (message "%s" counsel-grep-command)
   (let ((init-point (point))
         res)
     (unwind-protect
         (setq res (ivy-read "grep: " #'counsel-grep-function
                             :dynamic-collection t
                             :require-match t
                             :preselect
                             (when (< (- (line-end-position) (line-beginning-position)) 300)
                               (format "%d:%s"
                                       (line-number-at-pos)
                                       (regexp-quote
                                        (buffer-substring-no-properties
                                         (line-beginning-position)
                                         (line-end-position)))))
                             :keymap counsel-grep-map
                             :history 'counsel-grep-history
                             :re-builder #'ivy--regex
                             :action #'counsel-grep-action
                             :caller 'counsel-grep))
       (unless res
         (goto-char init-point))))))
#+END_SRC

**** Hacks
***** Fix case-insensitive wgrep

#+BEGIN_SRC elisp
(after! ivy
  (defadvice! respect-case-fold-search (args)
    :filter-return #'counsel--ag-extra-switches
    (concat args (pcase ivy-case-fold-search
                   (`auto " -S ")
                   (`t " -i ")
                   (`nil " -s ")))))
#+END_SRC

*** Javascript
**** Config

#+BEGIN_SRC elisp
(after! js2-mode
  :config
  (setq
   flycheck-javascript-eslint-executable (executable-find "eslint_d")
   flycheck-disabled-checkers '(javascript-jshint javascript))
  (add-hook 'js2-mode-hook #'eslintd-fix-mode))
#+END_SRC

**** Utils

#+BEGIN_SRC elisp
(defun +js/match-const-function-name (line)
  "Matches a line to the word after the declaration"
  (nth 2 (s-match
          "\\(const\\|let\\|class\\)\s\\(.+?\\)\s"
          line)))

(defun +js/const-function-at-point ()
  "Returns the current function name at the current line"
  (+js/match-const-function-name (thing-at-point 'line t)))
#+END_SRC

**** Functions
***** Export default variable

#+BEGIN_SRC elisp
(defun js2r-export-default ()
  "Exports the current declaration at the end of the file"
  (interactive)
  (save-excursion
    (let* ((name (+js/const-function-at-point)))
      (goto-char (point-max))
      (insert "\n")
      (insert (template "export default <<name>>;")))))
#+END_SRC

***** Extract constant to file

Extract the ~const~ under the cursor into a new file.

#+BEGIN_SRC elisp
(defun js2r-extract-const-to-file ()
  "Extracts function to external file"
  (interactive)
  (let* ((name (+js/const-function-at-point))
         (path (concat "./" name ".js")))
    (evil-digit-argument-or-evil-beginning-of-line)
    (js2r-kill)
    (f-write-text "" 'utf-8 path)
    (find-file path)
    (yank)))
#+END_SRC

***** Generate ~index.js~ file index

Generate a file index in the current file for every other file in the current directory.

#+BEGIN_SRC elisp
(defun +js/index-file-names (&optional dir)
  "Get filenames from current buffers directory."
  (let ((fs (directory-files (or dir default-directory) nil ".*\\.js")))
    (mapcar 'f-no-ext
            (remove "index.js" fs))))

(defun +js|generate-index (&optional dir ignore-list)
  "Generate an index import file for files in directory.
Pass DIR for directory, falls back to default-directory
Pass IGNORE-LIST for a list of files "
  (interactive)
  (erase-buffer)
  (let* ((dir (or dir default-directory))
         (fs (-->
              (+js/index-file-names dir)
              (if ignore-list
                  (--remove (-contains? ignore-list it) it)
                it))))
    (message "%s" fs)
    (mapc (lambda (f) (insert "import " f " from './" f "';\n")) fs)
    (insert "\n")
    (insert "export default {\n")
    (mapc (lambda (f) (insert "    " f ",\n")) fs)
    (insert "};")))
#+END_SRC

***** Convert expression into template string

Converts an expression into a template string.

Example:
When you would call the function on the ~foo~ inside the console.log,
It would wrap it like this ~console.log(`${foo}`)~.

#+BEGIN_SRC js :tangle no
const foo = 'Foo'
console.log(`${foo}`)
#+END_SRC

#+BEGIN_SRC elisp
(defun +js|convert-sexp-to-template-string ()
  "Wrap sexp into a template string"
  (interactive)
  (kill-sexp)
  (insert (concat "`${" (substring-no-properties (car kill-ring)) "}`"))
  (pop kill-ring))
#+END_SRC

***** Expand self closing tag

Converts self closing JSX tags to closing tags.
~<Foo />~ -> ~<Foo>|</Foo>~

#+BEGIN_SRC elisp
(defun +rjsx|expand-insert-self-closing-tag ()
  "Opens the current tag at any position of the cursor and starts insert mode"
  (interactive)
  (search-forward "/>")
  (evil-backward-char)
  (call-interactively #'delete-backward-char)
  (call-interactively #'rjsx-electric-gt)
  (newline)
  (call-interactively #'evil-indent-line)
  (call-interactively #'evil-open-above))
#+END_SRC

***** Extract Props from function arguments to body

#+BEGIN_SRC elisp
(defun +js|extract-props ()
  "Extract props object under the cursor."
  (interactive)
  (save-excursion
    (let* ((point-start (search-backward "{"))
           (point-end (search-forward "}"))
           (text (buffer-substring-no-properties point-start point-end)))
      (delete-region point-start point-end)
      (insert "props")
      (evil-open-below 1)
      (insert (template "const <<text>> = props;"))
      (search-backward "}")
      (js2r-expand-node-at-point)))
  (evil-normal-state))
#+END_SRC

***** Company Files

Remove the ~js~ extension for ~company-files~.

#+BEGIN_SRC elisp :tangle no
(defun company-js-files (command &optional arg &rest ignored)
  "Company complete path. Remove extension after completion"
  (interactive (list 'interactive))
  (require 'company)
  (cl-case command
    (interactive (company-begin-backend 'company-js-files))
    (prefix (company-files--grab-existing-name))
    (candidates (company-files--complete arg))
    (location (cons (dired-noselect
                     (file-name-directory (directory-file-name arg))) 1))
    (post-completion (when (s-matches? "\.js$" arg) (delete-backward-char 3)))
    (sorted t)
    (no-cache t)))

(map! :map js2-mode-map
      :i "C-x C-f" #'company-js-files)
#+END_SRC

***** Import JS File

#+BEGIN_SRC elisp :tangle no
(defun +js/import-file (file)
  (let ((cursor-postion (point))
        (filename (f-no-ext file)))
    (insert (template "import  from '<<filename>>';"))
    (goto-char cursor-postion)
    (forward-char 7)
    (evil-insert-state)))

(defun +js|ivy-import-file (&optional action)
  (interactive)
  (let* ((local-files
          (-->
           (-concat (list find-program) counsel-file-jump-args)
           (string-join it " ")
           shell-command-to-string
           split-string))
         (node-packages
          (-->
           (concat "jq -r '.dependencies | keys | .[]' " (concat (projectile-project-root) "package.json"))
           shell-command-to-string
           split-string))
         (imports (append local-files node-packages)))
    (ivy-read "Import file " imports :action (or action '+js/import-file))))
 #+END_SRC

***** Switch Ternary

#+BEGIN_SRC elisp
(defun js2r-ternary-switch-statements ()
  "Switch expressions in a ternary."
  (interactive)
  (js2r--guard)
  (js2r--wait-for-parse
   (save-excursion
     (let* ((ternary (js2r--closest 'js2-cond-node-p))
            (test-expr (js2-node-string (js2-cond-node-test-expr ternary)))
            (true-expr (js2-node-string (js2-cond-node-true-expr ternary)))
            (false-expr (js2-node-string (js2-cond-node-false-expr ternary)))
            (stmt (js2-node-parent-stmt ternary))
            (stmt-pre (buffer-substring (js2-node-abs-pos stmt) (js2-node-abs-pos ternary)))
            (stmt-post (s-trim (buffer-substring (js2-node-abs-end ternary) (js2-node-abs-end stmt))))
            (beg (js2-node-abs-pos stmt)))
       (goto-char beg)
       (delete-char (js2-node-len stmt))
       (insert "return " test-expr)
       (newline)
       (insert "? " false-expr)
       (newline)
       (insert ": " true-expr ";")
       (indent-region beg (point))))))
#+END_SRC

***** Ignore Flycheck error on line

#+BEGIN_SRC elisp
(defun +js|eslint-fix-ignore-error ()
  "Adds an ignore with the current flycheck error."
  (interactive)
  (if-let ((error-id (flycheck-copy-errors-as-kill (point) #'flycheck-error-id)))
    (save-excursion
      (previous-line)
      (end-of-line)
      (newline-and-indent)
      (insert (template "// eslint-disable-next-line <<error-id>>")))))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after js2-mode
 :map js2-mode-map
 :desc "Goto parent function" :n "gh" (λ! (js2-beginning-of-defun)))

(map!
 :after rjsx-mode
 :map rjsx-mode-map
 :localleader
 (:desc "Open Self-Closing Tag" :n ">" #'+rjsx|expand-insert-self-closing-tag)
 (:desc "Open Self-Closing Tag" :n "<" #'rjsx-rename-tag-at-point))
#+END_SRC

***** Evil Function Text Object Motion

Adds text objects for functions in javascript.
So you can press ~daf~ to delete a function.

#+BEGIN_SRC elisp
(add-hook! js-mode
  (require 'evil-text-objects-javascript)
  (evil-text-objects-javascript/install))
#+END_SRC

***** Evil Method Text Object Motion

Overwrite ~evil-text-objects-javascript~ to also accepts methods.

I mainly changed the function marking helper.

#+BEGIN_SRC diff :tangle no
- (call-interactively #'mark-defun)
+ (call-interactively #'js2-mark-defun)
#+END_SRC

#+BEGIN_SRC elisp
(after! evil-text-objects-javascript
  (evil-define-text-object
    evil-inner-javascript-function (count &optional beg end type)
    "inner text object for all javascript functions."
    (call-interactively #'js2-mark-defun)
    (narrow-to-region (region-beginning) (region-end))
    (goto-char (point-min))
    (let* ((beg (save-excursion
                  (search-forward "(")
                  (backward-char)
                  (evil-jump-item)
                  (search-forward-regexp "[({]")
                  (point)))
           (end (save-excursion
                  (goto-char beg)
                  (evil-jump-item)
                  (point))))
      (evil-range beg end type)))

  (evil-define-text-object
    evil-outer-javascript-function (count &optional beg end type)
    "Outer text object for all Javascript functions."
    (call-interactively #'js2-mark-defun)
    (narrow-to-region (region-beginning) (region-end))
    (goto-char (point-min))
    (let* ((beg (save-excursion
                  (when (looking-at "[[:space:]]")
                    (evil-forward-word-begin))
                  (point)))
           (end (save-excursion
                  (goto-char beg)
                  (search-forward "(")
                  (backward-char)
                  (evil-jump-item)
                  (search-forward-regexp "[({]")
                  (evil-jump-item)
                  (forward-char)
                  (if (save-excursion
                        (progn
                          (forward-char)
                          (when (looking-at ",") (point))))
                    (point)))))
      (evil-range beg end type))))
#+END_SRC

*** JSON
**** Utils
***** Is Last JSON key at point

#+BEGIN_SRC elisp
(defun +json/is-last-key? ()
  "Is the next line the last json key."
  (save-excursion
    (forward-line)
    (buf-line-has "}")))
#+END_SRC

***** Insert JSON Key

Insert JSON key in a json document
This functions is dependant on the yasnippet: [[file:snippets/json-mode/key::# --][key]]

#+BEGIN_SRC elisp
(defun +json/insert-key (&optional above?)
  "Adds a new JSON key pair."
  (let ((last-line? (buf-line-has ",$")))
    ;; Insert comma
    (if (and (not last-line?) (not above?))
        (replace-regexp "$" "," nil (point-at-bol) (point-at-eol)))
    (end-of-line)
    (if above?
        (evil-insert-newline-above)
      (evil-insert-newline-below))
    (indent-according-to-mode)
    (yas/insert-by-name "key")))

(defun +json|insert-key-above ()
  "Function docstring"
  (interactive)
  (+json/insert-key t))

(defun +json|insert-key-below ()
  "Function docstring"
  (interactive)
  (+json/insert-key nil))
#+END_SRC

***** Autofix JSON

Uses [[https://www.npmjs.com/package/json-fix][json-fix]] to autofix JSON files.

#+BEGIN_SRC bash :tangle no
npm i -g json-fix
#+END_SRC

#+BEGIN_SRC elisp
(defun +json|autofix-buffer ()
  "Autofix json buffer"
  (interactive)
  (let ((b (if mark-active (min (point) (mark)) (point-min)))
        (e (if mark-active (max (point) (mark)) (point-max))))
    (shell-command-on-region b e
     (template "json-fix --no-sort --spaces <<tab-width>>") (current-buffer) t)))
#+END_SRC

**** Bindings
#+BEGIN_SRC elisp
(map!
 :after json-mode
 :map json-mode-map
 :gni [s-return] #'+json/insert-key-below
 :gni [s-S-return] #'+json/insert-key-above)
#+END_SRC

*** LSP
**** Disable LSP hover

#+BEGIN_SRC elisp :tangle no
(use-package! lsp-mode
  :config
  (setq lsp-eldoc-render-all nil
        lsp-eldoc-enable-hover nil
        lsp-eldoc-enable-signature-help nil
        lsp-eldoc-prefer-signature-help nil
        lsp-inhibit-message t
        lsp-highlight-symbol-at-point nil
        ;; Disable make error highlighting
        lsp-prefer-flymake nil))
#+END_SRC

**** Disable LSP hover face

#+BEGIN_SRC elisp :tangle no
(add-hook! 'doom-load-theme-hook
  (after! lsp
    (dolist (face '(lsp-face-highlight-read
                    lsp-face-highlight-write
                    lsp-face-highlight-textual))
      (set-face-attribute
       face nil
       :foreground nil :distant-foreground nil :background nil))))
#+END_SRC

*** Mail
**** Config
***** Disable Background Color

#+BEGIN_SRC elisp
(setq shr-use-colors nil)
#+END_SRC

***** Shortcuts

#+BEGIN_SRC elisp
(setq mu4e-maildir-shortcuts
      '(("/mailbox/work/INBOX"     . ?i)
        ("/mailbox/work/Sent Mail" . ?s)
        ("/mailbox/work/Trash"     . ?t)
        ("/mailbox/work/All Mail"  . ?a)))
#+END_SRC

***** Automatically apply Section without asking

#+BEGIN_SRC elisp
(setq mu4e-headers-leave-behavior 'apply)
#+END_SRC

*** Magit / Git
**** Utils
***** Create New Git Worktree Workspace

Creates a new git workspace from a branch.
Automatically adds ~.projectfile~ and opens a new doom workspace.

#+BEGIN_SRC elisp
(defun magit-worktree-branch-project-worktree (branch start-point &optional force)
  "Create a new BRANCH and check it out in a new worktree at PATH in a new workspace."
  (interactive
   `(,@(butlast (magit-branch-read-args "Create and checkout branch"))
     ,current-prefix-arg))
  (let* ((worktree-path (f-join (projectile-project-root) ".worktrees"))
         (path (f-join (projectile-project-root) ".worktrees" branch)))
    (when (not (f-exists-p worktree-path))
      (mkdir worktree-path t))
    (magit-run-git "worktree" "add" (if force "-B" "-b")
                   branch (expand-file-name path) start-point)
    (f-touch (f-join path ".projectile"))
    (+workspace-new branch)
    (+workspace-switch branch)
    (magit-diff-visit-directory path)
    (projectile-add-known-project path)
    path))
#+END_SRC

***** Revision show orignal file

Show the orginal file when visiting a revision buffer.
E.g.: When showing a diff from a commit, you may want to edit that file.

#+BEGIN_SRC elisp
(defun magit-revision-show-original-file ()
  "Show the orginal file from a revision buffer
If possible also go to the pointing line"
  (interactive)
  (when magit-buffer-file-name
    (let ((file-name magit-buffer-file-name)
          (line-number (line-number-at-pos)))
      (if current-prefix-arg
          (delete-other-windows))
      (find-file file-name)
      (goto-line line-number))))
#+END_SRC

***** Git changed files

Show a list of the changed files in the current branch.
For now only works on branches that were directly forked from master.

#+BEGIN_SRC elisp
(defun shell-command-to-list (cmd)
  "Split output from shell-command to list"
  (split-string (shell-command-to-string cmd) "\n" t))

(defun git-new-files ()
  (shell-command-to-list "git ls-files -om --exclude-standard"))

(defun git-modified-files (&optional branch)
  (shell-command-to-list
   (template "git --no-pager diff --no-renames --name-only --no-merges <<(magit-rev-parse \"HEAD\")>> <<branch>>;")))

(defun git-get-changed-files (b)
    (delete-dups (append (git-modified-files b) (git-new-files))))

(defun +git|ivy-changed-files (&optional branch)
  (interactive)
  (let ((enable-recursive-minibuffers t))
    (ivy-read (template "Changed files for <<(or branch (magit-get-current-branch))>>:")
              (git-get-changed-files (or "origin/master"))
              :require-match t
              :history 'file-name-history
              :action counsel-projectile-find-file-action
              :caller '+git|ivy-changed-files)))
#+END_SRC
***** Git undo

#+BEGIN_SRC elisp
(defun +git|undo ()
  "Soft reset current git repo to HEAD~1."
  (interactive)
  (magit-reset-soft "HEAD~1"))
#+END_SRC

***** Push dated remote branch

For work I need remote branches with a date prefix.

#+BEGIN_SRC elisp
(defun +git|push-dated (&optional branch)
  "Pushes the given the current BRANCH with a dated prefix
my-branch-name -> 19-01-my-branch-name
When no BRANCH is given, take the current one."
  (interactive)
  (let* ((branch (or branch (magit-get-current-branch)))
         (date (format-time-string "%y-%m"))
         (remote (template "origin/<<date>>-<<branch>>")))
    (magit-git-push branch remote "--set-upstream")))
#+END_SRC

***** Diff Range from current branch to ~magit-thing-at-point~

When I'm on the log view, I want to quickliy diff it against the currently checked out branch.
The transient shortcut for this is ~d R~ define [[*Transient][here]].

#+BEGIN_SRC elisp
(defun +magit|diff-range-from-current-branch ()
  "Ranged diff from the checked out branch to the commit at point."
  (interactive)
  (magit-diff-range (template "<<(magit-commit-at-point)>>..<<(magit-get-current-branch)>>")))
#+END_SRC

***** Create review branch

#+BEGIN_SRC elisp
(defun +magit|delete-review-branches ()
  "Delete all review branches that no longer have an upstream."
  (interactive)
  (--> (magit-list-branches)
       (--filter (s-starts-with? "refs/heads/REVIEW" it) it)
       (--map (magit-name-local-branch it) it)
       (--reject (magit-get-upstream-branch it) it)
       (--each (magit-branch-delete it t) it)))

(defun +magit|checkout-review-branch (&optional branch start-point)
  "Create a branch with review prefix for easy cleanup afterwards."
  (interactive)
  (let* ((remotes (magit-list-remote-branch-names))
         (atpoint (magit-branch-at-point))
         (branch (magit-completing-read
                  "Checkout branch" remotes
                  nil nil nil 'magit-revision-history
                  (or (car (member atpoint remotes))
                      (and atpoint
                           (car (member (and (string-match "[^/]+/" atpoint)
                                             (substring atpoint (match-end 0)))
                                        remotes)))))))
    (magit-checkout branch)
    (when (magit-anything-modified-p)
      (user-error "Cannot checkout when there are uncommitted changes"))
    (magit-branch-and-checkout (s-replace "origin/" "REVIEW-" branch) branch)))
#+END_SRC

***** TODO Browse git link

Browse the current thing at point for git

#+BEGIN_SRC elisp
(defun browse-git-link ()
  "Browse the git link at the current point"
  (interactive)
  (let ((git-link-open-in-browser t))
    (call-interactively 'git-link)))
#+END_SRC

**** Config

#+BEGIN_SRC elisp
(after! magit
  :config
  (setq
   magit-save-repository-buffers 'dontask
   magithub-clone-default-directory "~/Code/Repositories"
   git-commit-summary-max-length 120))
#+END_SRC

**** Bindings
***** Diff Navigation

My workflow for navigating diffs
Use ~z1~ to fold all diffs to their file headers and presss ~{~ or ~}~ to

1. Refold all sections
2. Go to the next section
3. Unfold everything in the current section

Then use ~]~ to navigate the sections

#+BEGIN_SRC elisp
(defun floscr:magit-jumpunfold-section (&optional forward)
  "Fold all section. Go to next section when FORWARD. Show all children"
  (interactive)
  (magit-section-show-level-1-all)
  (call-interactively (if forward #'magit-section-forward-sibling #'magit-section-backward-sibling))
  (call-interactively #'magit-section-show-children))

(map!
 (:after evil-magit
   :map (magit-diff-mode-map)
   :n "}" (λ! (floscr:magit-jumpunfold-section 't))
   :n "{" (λ! (floscr:magit-jumpunfold-section))))
#+END_SRC

***** Magit Window Navigation Binding Fixes

Fixes evil window navigation for magit special buffers

#+BEGIN_SRC elisp
(map!
 (:after evil-magit
   :map (magit-status-mode-map magit-revision-mode-map magit-diff-mode-map)
   :n "C-j" #'evil-window-down
   :n "C-k" #'evil-window-up
   :n "C-h" #'evil-window-left
   :n "C-l" #'evil-window-right))
#+END_SRC

***** Time Machine Navigation

#+BEGIN_SRC elisp
(map!
 :after git-timemachine
 :map git-timemachine-mode-map
 :n "[[" #'git-timemachine-show-previous-revision
 :n "]]" #'git-timemachine-show-previous-revision)
#+END_SRC

**** Transient

You can add flags or commands to the magit interface transient here.
To append something, just state the flag that you see in the transient popup as the 2nd argument.

#+BEGIN_SRC elisp
(after! magit
  (transient-append-suffix 'magit-log "-f" '("-0" "No merges" "--no-merges"))
  (transient-append-suffix 'magit-push "p" '("d" "dated" +git|push-dated))
  (transient-append-suffix 'magit-diff "d" '("R" "Diff range from current branch" +magit|diff-range-from-current-branch))
  (transient-append-suffix 'magit-commit
    "-D" '("-D" "Override the author date" "--date=" transient-read-date))
  (transient-append-suffix 'magit-branch "l" '("R" "Create review branch" +magit|checkout-review-branch)))
#+END_SRC

*** Markdown

Always keep markdown centered, without line numbers.

#+BEGIN_SRC elisp
(use-package! markdown-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.mdx\\'" . markdown-mode))
  (setq markdown-fontify-code-blocks-natively t)
  :config
  (add-hook! markdown-mode
    (hl-line-mode -1)
    (visual-line-mode)
    (visual-fill-column-mode)
    (outline-minor-mode)
    (setq visual-fill-column-width 90
          display-line-numbers nil)
    (setq line-spacing 2
          fill-column 80))

  (map! (:map markdown-mode-map
          :n "<"    #'markdown-promote
          :n ">"    #'markdown-demote)))
#+END_SRC


*** Nov (Epub Reading Mode)

Adds epub reading mode
[[https://github.com/wasamasa/nov.el][wasamasa/nov.el: Major mode for reading EPUBs in Emacs]]

I want to keep the buffer centered, but let nov take care of breaking the text,
since this is much nicer then ~visual-line-mode~.

#+BEGIN_SRC elisp
(defun my-nov-config ()
  (setq line-spacing 5)
  (face-remap-add-relative 'variable-pitch :family "Liberation Serif" :height 1.4)
  (setq visual-fill-column-center-text t)
  (setq visual-fill-column-width (+ nov-text-width 25))
  (visual-fill-column-mode t))

(use-package! nov
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  (setq nov-text-width 75)
  :config
  (progn
    (add-hook 'nov-mode-hook 'my-nov-config)))
#+END_SRC

The font can be installed via brew cask.

#+BEGIN_SRC bash :tangle no
brew tap homebrew/cask-fonts
brew cask install font-liberation-sans
#+END_SRC

*** NPM Mode
**** Add CI command

#+BEGIN_SRC elisp
(defun npm-mode-npm-ci ()
  "Run the 'npm install' command."
  (interactive)
  (npm-mode--exec-process "npm ci"))
#+END_SRC

*** PDF Tools

#+BEGIN_SRC elisp
;; Fix midnight colors for doom-one theme
(setq pdf-view-midnight-colors '("#BBC2CD" . "#282C34"))
#+END_SRC

*** rainbow-mode

#+BEGIN_SRC elisp
(use-package! rainbow-mode
  :commands (rainbow-mode))
#+END_SRC

*** Smerge Mode
**** Fix Colors

#+BEGIN_SRC elisp
(after! smerge-mode
  :config
  ;; TODO This is broken after switching the theme but works for now
  ;; This fixes the smerge diff color is really bright an ugly
  (set-face-attribute 'smerge-refined-added nil :foreground nil :background nil))
#+END_SRC

**** Hydra
:PROPERTIES:
:SOURCE:   [[https://github.com/alphapapa/unpackaged.el#hydra][alphapapa/unpackaged.el: A collection of useful Emacs Lisp code that isn't substantial enough to be packaged]]
:END:

#+BEGIN_SRC elisp
(use-package smerge-mode
  :after hydra
  :config
  (defhydra unpackaged/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (flycheck-mode -1)
                                     (unpackaged/smerge-hydra/body)))))
#+END_SRC

*** Workspaces
**** Config
***** Always add buffers to current workspace

Doom per default adds buffers to the current workspace on ~find-file~.
I want buffers added whenever I visit a buffer.

#+BEGIN_SRC elisp
(after! persp-mode
  (defun +workspace*add-special-buffer ()
    (if-let* ((name (buffer-name))
              (add-buffer? (or
                            ;; Always add files to workspaces
                            (buffer-file-name)
                            ;; Add src buffer
                            (s-matches? "\\*Org Src.*" name))))
      (persp-add-buffer (current-buffer) (get-current-persp))))

  (add-hook 'doom-switch-buffer-hook #'+workspace*add-special-buffer))
#+END_SRC

**** Functions
***** Switch to workspace

Enhancement of the default ~+workspace/switch-to~.
This allows quick deletion of workspaces from ivy with ~CTRL + BACKSPACE~.

#+BEGIN_SRC elisp
(defvar counsel-workspace-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-<backspace>") #'+workspace/switch-to-delete-space)
    map))

(defun +workspace//switch-to-delete-space (workspace)
  (let* ((current-workspace-name (+workspace-current-name))
         (new-workspace-name
            (or (--first (string= current-workspace-name it) (+workspace-list-names)) "main")))
    (+workspace/delete workspace)
    (+workspace-switch new-workspace-name)
    (+workspace/my-switch-to)))

(defun +workspace/switch-to-delete-space ()
  (interactive)
  (ivy-set-action #'+workspace//switch-to-delete-space)
  (ivy-done))

(defun +workspace/my-switch-to ()
  (interactive)
  (ivy-read "Switch to workspace: "
            (+workspace-list-names)
            :keymap counsel-workspace-map
            :action #'+workspace/switch-to))
#+END_SRC
***** Find file for workspace

Most of the time you create workspaces from a project.
But when the CWD has changed in that workspace, you would have to relocate to
the projects cwd to find a file.

#+BEGIN_SRC elisp
(defun +workspace/workspace-project-root (&optional arg)
  "Gets the root dir for the current workspace"
  (--find (s-match (concat (+workspace-current-name) "/$") it) projectile-known-projects))

(defun +workspace|find-workspace-project-file ()
"Projectile find file for the project named after the current workspace."
  (interactive)
  (cl-letf (((symbol-function 'projectile-project-root) #'+workspace/workspace-project-root))
      (projectile-find-file)))
#+END_SRC

***** New named workspace

#+BEGIN_SRC elisp
(defun +workspace/new-named ()
  "Create a new named workspace."
  (interactive)
  (let ((name (read-string "New workspace name: ")))
    (if name (+workspace/new name))))
#+END_SRC

***** Cleanup Workspace

#+BEGIN_SRC elisp
(defun +workspace/remove-other-buffers (&optional keep-alive?)
  "Kill or remove all other buffers from current workspace."
  (interactive)
  (--> (+workspace-buffer-list)
       (--reject (eq (current-buffer) it) it)
       (if keep-alive?
           (persp-remove-buffer it)
         (kill-buffer it))))

(defun +workspace|hide-other-buffers ()
  "Hide all inactive buffers from the current workspace."
  (interactive)
  (+workspace/remove-other-buffers t))

(defun +workspace|kill-other-buffers ()
  "Kill all interactive buffers from the current workspace."
  (interactive)
  (+workspace/remove-other-buffers))

(defun +workspace|hide-non-project-buffers ()
  "Hide all file buffers that don't belong to the project workspace."
  (interactive)
  (let ((project-path (or (expand-file-name (+workspace/workspace-project-root))
                          (projectile-project-root))))
    (-some--> (+workspace-buffer-list)
         ;; Dont remove non-remove buffers
         (--filter (buffer-file-name it) it)
         (--reject (s-contains? project-path (buffer-file-name it)) it)
         (--each (persp-remove-buffer it) it))))
#+END_SRC

**** Add buffer to workspace hooks

Fix buffers not being added to the current workspace.

***** Bookmarks

#+BEGIN_SRC elisp
(add-hook! 'bookmark-after-jump-hook #'+workspaces-add-current-buffer-h)
#+END_SRC

*** Wgrep Mode
**** Bindings

#+BEGIN_SRC elisp
(map!
 :map wgrep-mode-map
 :g [return] #'compile-goto-error)
#+END_SRC

*** Yasnippet
**** Utils
***** Expand snippet by name
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/10211730/insert-yasnippet-by-name][emacs - Insert yasnippet by name - Stack Overflow]]
:END:

#+BEGIN_SRC elisp
(defun yas/insert-by-name (name)
  (flet ((dummy-prompt
          (prompt choices &optional display-fn)
          (declare (ignore prompt))
          (or (find name choices :key display-fn :test #'string=)
              (throw 'notfound nil))))
    (let ((yas/prompt-functions '(dummy-prompt)))
      (catch 'notfound
        (yas/insert-snippet t)))))
#+END_SRC

***** TODO Expand first company snippet

#+BEGIN_SRC elisp :tangle no
(defun yasnippet/expand-first-item ()
  (interactive)
  (call-interactively #'company-yasnippet)
  (company-complete-selection))
#+END_SRC
*** Babel Async

#+BEGIN_SRC elisp
(use-package! ob-async
  :after org-babel)
#+END_SRC

** General Config
*** Garbage Collection

Set it to ~32 MiB~.

#+BEGIN_SRC elisp
(setq doom-gc-cons-threshold 33554432)
#+END_SRC

*** Lookup Sources

#+BEGIN_SRC elisp
(setq +lookup-provider-url-alist
  '(("DuckDuckGo"        . "https://duckduckgo.com/?q=%s")
    ("DuckDuckGo Lucky"  . "https://duckduckgo.com/?q=\\%s")
    ("Github Code"       . "https://github.com/search?search&q=%s&type=Code")
    ("Google"            . "https://google.com/search?q=%s")
    ("Google images"     . "https://google.com/images?q=%s")
    ("Google maps"       . "https://maps.google.com/maps?q=%s")
    ("NPM"               . "https://npmjs.com/search?q=%s")
    ("Hoogle"            . "https://www.haskell.org/hoogle/?hoogle=%s")
    ("Project Gutenberg" . "http://www.gutenberg.org/ebooks/search/?query=%s")
    ("Explain Shell"     . "https://explainshell.com/explain?cmd=%s")
    ("StackOverflow"     . "https://stackoverflow.com/search?q=%s")
    ("Github"            . "https://github.com/search?ref=simplesearch&q=%s")
    ("Youtube"           . "https://youtube.com/results?aq=f&oq=&search_query=%s")
    ("Wolfram alpha"     . "https://wolframalpha.com/input/?i=%s")
    ("Wikipedia"         . "https://wikipedia.org/search-redirect.php?language=en&go=Go&search=%s")))
#+END_SRC

*** Bookmarks

#+BEGIN_SRC elisp
(setq bookmark-default-file "~/Documents/Temp/bookmarks"
      bookmark-file bookmark-default-file
      bookmark-old-default-file bookmark-default-file)
#+END_SRC

**** Automatically Save Bookmarks
:PROPERTIES:
:SOURCE:   [[https://github.com/yangyingchao/tubo-env/blob/b5f61ed6a802af45e461927507de55ed7e527983/.emacs.d/rc/03-fundamental-mode.el#L193][tubo-env/03-fundamental-mode.el at b5f61ed6a802af45e461927507de55ed7e527983 · yangyingchao/tubo-env]]
:END:

Automatically save bookmarks file after changing bookmarks.
Also prevent the ~bookmark-save~ function to display the "Saved" message.

#+BEGIN_SRC elisp
(defun +bookmark/set (func &rest args)
  "Save bookmark after `bookmark-set'.
Call FUNC with ARGS."
  (and (bookmark-time-to-save-p t)
       (let ((inhibit-message t))
         (bookmark-save))))

(advice-add 'bookmark-set :after #'+bookmark/set)
(advice-add 'bookmark-delete :after #'+bookmark/set)
(advice-add 'bookmark-rename :after #'+bookmark/set)
#+END_SRC
*** Open OTF fonts in image mode

#+BEGIN_SRC elisp
(add-to-list 'auto-mode-alist '("\\.otf\\'" . image-mode))
#+END_SRC

*** Shorten Yes/No prompts
:PROPERTIES:
:SOURCE:   https://github.com/wasamasa/dotemacs/blob/master/init.org#shorten-yesno-prompts
:END:

Per default you're required to type out a full "yes" or "no" whenever
the function ~yes-or-no-p~ is invoked, let's substitute its function
definition to allow a "y" or "n" without even requiring confirmation.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Fine undo

Whether actions like "cw" are undone in several steps.

#+BEGIN_SRC elisp
(setq evil-want-fine-undo t)
#+END_SRC

*** Move items to trash on delete

#+BEGIN_SRC elisp
(setq
 trash-directory "~/.Trash/"
 delete-by-moving-to-trash t)
#+END_SRC

*** Filename Auto Modes

Automatically set mode for specific filenames.

#+BEGIN_SRC elisp
;; auto-mode-alist
(add-to-list 'auto-mode-alist '("Brewfile" . shell-script-mode))
#+END_SRC

*** Automatically reload tags files

#+BEGIN_SRC elisp
(setq tags-revert-without-query 1)
#+END_SRC

** Bindings
*** General Bindings

#+BEGIN_SRC elisp
(map! :en "C-±" #'+popup/raise)
#+END_SRC

**** Disable emacs-state-toggle

Other Bindings for multi-edit:

| Bindings | Description                       |
| M+d      | Match next                        |
| M+D      | Match previous                    |
| M+c+d    | Restore previous matching session |

#+BEGIN_SRC elisp
(map! :nm "C-z" nil)
#+END_SRC

*** Super bindings

#+BEGIN_SRC elisp
(map!
 (:map override
   :gniv "s-;" #'eval-expression
   :gniv "s-a" #'mark-whole-buffer
   :gniv "s-s" #'save-buffer
   :gniv "s-v" #'yank
   :gniv "s-x" #'execute-extended-command
   :gniv "s-y" #'helm-show-kill-ring

   ;; Text scale
   :gniv "s-="   #'doom/increase-font-size
   :gniv "s--"   #'doom/decrease-font-size
   :gniv "s-0"   #'doom/reset-font-size))
#+END_SRC

*** Function Key Bindings

#+BEGIN_SRC elisp
(map!
 (:map override
   :gniv "<f5>" #'global-auto-revert-mode))
#+END_SRC

*** Evil Normal Bindings
**** Window navigation

#+BEGIN_SRC elisp
(map!
 :en "C-h"   #'evil-window-left
 :en "C-j"   #'evil-window-down
 :en "C-k"   #'evil-window-up
 :en "C-l"   #'evil-window-right)

(map!
 :map evil-org-mode-map
 :en "C-h"   #'evil-window-left
 :en "C-j"   #'evil-window-down
 :en "C-k"   #'evil-window-up
 :en "C-l"   #'evil-window-right)
#+END_SRC

**** History navigation in minibuffer

#+BEGIN_SRC elisp
(define-key minibuffer-local-map "\C-p" 'previous-history-element)
(define-key minibuffer-local-map "\C-n" 'next-history-element)
#+END_SRC

**** Jump to last buffer

#+BEGIN_SRC elisp
(map! :n "gb" #'evil-switch-to-windows-last-buffer)
#+END_SRC

**** Select last paste
:PROPERTIES:
:SOURCE:   https://emacs.stackexchange.com/a/21093
:END:

#+BEGIN_SRC elisp
(defun +evil|select-pasted ()
  (interactive)
  (let ((start-marker (evil-get-marker ?\[))
        (end-marker (evil-get-marker ?\])))
    (evil-visual-select start-marker end-marker)))

(map! :n "gp" #'+evil|select-pasted)
#+END_SRC

*** Evil Motions
**** Replace With Register Motion

Replace the current selection with a register.

#+BEGIN_SRC elisp
(use-package! evil-replace-with-register
  :config
  (setq evil-replace-with-register-key (kbd "gr"))
  (define-key evil-normal-state-map
    evil-replace-with-register-key 'evil-replace-with-register)
  (define-key evil-visual-state-map
    evil-replace-with-register-key 'evil-replace-with-register))
#+END_SRC

**** Additional text objects

#+BEGIN_SRC elisp
(after! evil
  (require 'evil-textobj-anyblock)
  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote)
  (define-key evil-inner-text-objects-map "r" 'evil-inner-bracket)
  (define-key evil-inner-text-objects-map "B" 'evil-inner-curly))
#+END_SRC

**** Go up one directory from the current buffer

#+BEGIN_SRC elisp
(map! :m "-"  #'dired-jump)
#+END_SRC

**** Up to next/previous indent

Text objects for lines after or before the current line, that have the same or deeper indent.

#+BEGIN_SRC elisp
(defun evil-indent-plus--line-down-indent-range (&optional point)
  (require 'evil-indent-plus)
  (let* ((range (evil-indent-plus--same-indent-range point))
         (base (point))
         (begin (point)))
    (list begin (cl-second range) base)))

(evil-define-text-object evil-indent-plus-i-indent-line-down (&optional count beg end type)
  "Text object describing the block with the same (or greater) indentation as the current line,
and the line above, skipping empty lines."
  :type line
  (evil-indent-plus--linify (evil-indent-plus--line-down-indent-range)))

(define-key evil-inner-text-objects-map "}" 'evil-indent-plus-i-indent-line-down)

(defun evil-indent-plus--line-up-indent-range (&optional point)
  (require 'evil-indent-plus)
  (let* ((range (evil-indent-plus--same-indent-range point))
         (base (point))
         (begin (point)))
    (list begin (cl-first range) base)))

(evil-define-text-object evil-indent-plus-i-indent-line-up (&optional count beg end type)
  "Text object describing the block with the same (or greater) indentation as the current line,
and the line above, skipping empty lines."
  :type line
  (evil-indent-plus--linify (evil-indent-plus--line-up-indent-range)))

(define-key evil-inner-text-objects-map "{" 'evil-indent-plus-i-indent-line-up)
#+END_SRC

*** Evil Text Objects

Custom evil text objects mostly stolen from [[https://github.com/jerryxgh/lambda-x/blob/master/lambda-evil.el#L236][Spacemacs|define-text-object-regexp]].

**** Utils
***** Define Text Objects

#+BEGIN_SRC elisp
(defmacro +evil/define-text-object-regexp (key name start-regexp end-regexp)
  "Define a text object.
START-REGEXP and END-REGEXP are the boundaries of the text object."
  (let ((inner-name (make-symbol (concat "evil-inner-" name)))
        (outer-name (make-symbol (concat "evil-outer-" name))))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regexp ,end-regexp beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regexp ,end-regexp beg end type count t))
       (define-key evil-inner-text-objects-map ,key (quote ,inner-name))
       (define-key evil-outer-text-objects-map ,key (quote ,outer-name)))))
#+END_SRC
**** Config

#+BEGIN_SRC elisp
(+evil/define-text-object-regexp "~" "tilde" "~" "~")
(+evil/define-text-object-regexp "=" "equal" "=" "=")
(+evil/define-text-object-regexp "|" "bar" "|" "|")
(+evil/define-text-object-regexp "*" "star" "*" "*")
(+evil/define-text-object-regexp "$" "dollar" "$" "$")
(+evil/define-text-object-regexp "%" "percent" "%" "%")
(+evil/define-text-object-regexp "/" "slash" "/" "/")
(+evil/define-text-object-regexp "_" "underscore" "_" "_")
(+evil/define-text-object-regexp "-" "hyphen" "-" "-")
#+END_SRC

**** Quotes Text Object

Changes the text matching inside quotes with ~q~ motion (e.g. ~ciq~)
Change inner bracket with ~r~

#+BEGIN_SRC elisp
(after! evil
  (require 'evil-textobj-anyblock)
  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote)
  (define-key evil-inner-text-objects-map "r" 'evil-inner-bracket))
#+END_SRC
*** Evil Square Bracket Bindings

Global ~[~ & ~]~ combinator bindings

**** Dumb Jump

#+BEGIN_SRC elisp
(map!
 :n "]F" #'dumb-jump-go
 :n "[F" #'dumb-jump-back)
#+END_SRC

**** Flycheck Error Jumping

#+BEGIN_SRC elisp
(map!
 :n "]e" #'flycheck-next-error
 :n "[e" #'flycheck-previous-error)
#+END_SRC

*** Evil Insert Bindings

Insert Mode bindings, mostly unicode insertion and workaround for german umlaut.

**** Insert from the kill ring in insert mode

#+BEGIN_SRC elisp
(map! :i "A-y" #'helm-show-kill-ring)
#+END_SRC

**** Unicode Symbols and German Umlaut

#+BEGIN_SRC elisp
(map!
 :i "M-;"   (λ! (insert "ö"))
 :i "M-:"   (λ! (insert "Ö"))
 :i "M-'"   (λ! (insert "ä"))
 :i "M-\""  (λ! (insert "Ä"))
 :i "M-["   (λ! (insert "ü"))
 :i "M-{"   (λ! (insert "Ü"))
 :i "M-s"   (λ! (insert "ß"))
 :i "M-e"   (λ! (insert "€"))
 :i "M-`"   (λ! (insert "°"))
 :i "M-."   (λ! (insert "…"))
 :i "M-^"   (λ! (insert "°"))
 :i "M-l"   (λ! (insert "λ"))
 :i "M-w"   (λ! (insert "⚠"))
 :i "M-i"   (λ! (insert "ℹ")))
#+END_SRC
*** Evil Ex Commands

Extend the default evil ex commands from [[file:~/.emacs.d/modules/editor/evil/+commands.el::;;; editor/evil/+commands.el -*- lexical-binding: t; -*-][+commands.el]]

#+BEGIN_SRC elisp
(after! evil-ex
  :config
  (evil-ex-define-cmd "W" #'evil-write))
#+END_SRC

*** Leader Bindings

#+BEGIN_SRC elisp
(map!
 :leader
 "'"  #'+popup/toggle
 "au" #'undo-tree-visualize
 "//" #'+default/search-project
 "-"  #'quick-calc)
#+END_SRC

**** Buffer

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("b" . "buffer")
   :desc "Rename Buffer"  "r" #'rename-buffer))
#+END_SRC

**** Directory

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("d" . "directory")
   :desc "Project Root"  "p" (λ! (find-file (projectile-project-root)))
  (:prefix-map ("g" . "goto")
    :desc "Downloads" "d" (λ! (find-file "~/Downloads"))
    :desc "Desktop" "D" (λ! (find-file "~/Desktop"))
    :desc "Code" "c" (λ! (find-file "~/Code"))
    :desc "Tmp" "t" (λ! (find-file "/tmp"))
    :desc "Home" "h" (λ! (find-file "~")))))
#+END_SRC

**** File

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("f" . "file")
   :desc "Open Private Config" "P" (λ! (find-file (f-join doom-private-dir "config.org")))
   (:prefix-map ("g" . "goto")
    :desc "Last captured" "c" (λ! (org-goto-marker-or-bmk org-capture-last-stored-marker))
    :desc "Last refiled" "r" (λ! (org-refile-goto-last-stored)))))
#+END_SRC

**** Git

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("g" . "git")
   :desc "Worktree Popup"              "%" #'magit-worktree
   :desc "Amend Commit (No Message)"   "A" (λ! (magit-commit-amend "--no-edit"))
   :desc "Blame"                       "B" #'magit-blame
   :desc "Changed Files"               "F" #'+git|ivy-changed-files
   :desc "New Branch"                  "N" #'magit-branch-spinoff
   :desc "Show revision original File" "O" #'magit-revision-show-original-file
   :desc "Map-editor Changed Files"    "T" (λ! (+git|ivy-changed-files "map-editor"))
   :desc "Amend Commit"                "a" #'magit-commit-amend
   :desc "Checkout"                    "b" #'magit-checkout
   :desc "Diff"                        "d" #'magit-diff
   :desc "Push"                        "p" #'magit-push
   :desc "Undo"                        "u" #'+git|undo))
#+END_SRC

**** Insert

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("i" . "insert")
   :desc "Killring"       "y" #'helm-show-kill-ring))
#+END_SRC

**** Open

#+BEGIN_SRC elisp
(map!
 :leader
 (:desc "open" :prefix "o"
   :desc "Mail"                         :g "m" #'=mu4e
   :desc "Calendar"                     :g "c" #'=calendar
   :desc "Calc"                         :g "C" #'calc))
#+END_SRC

**** Projects

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("p" . "project")
   :desc "Workspace Project Files"     "P" #'+workspace|find-workspace-project-file))
#+END_SRC

**** Toggle

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("t" . "toggle")
   :desc "Theme Dark/Light"     "t" #'+doom|toggle-theme))
#+END_SRC

**** Window

#+BEGIN_SRC elisp
(map!
 :leader
 :desc  "Split Vertical"        "|"    #'evil-window-vsplit
 :desc  "Split Horizontal"      "-"    #'evil-window-split
 (:prefix-map ("w" . "window")
  :desc  "Delete"               "d"    #'delete-window
  :desc  "New"                  "n"    #'evil-window-new
  :desc  "Split Vertical"       "|"    #'evil-window-vsplit
  :desc  "Split Horizontal"     "_"    #'evil-window-split
  :desc  "Set Height"           "C-_"  #'evil-window-set-height
  :desc  "Set Height"           "C-|"  #'evil-window-set-width
  :desc  "Swap"                 "SPC"  #'ace-swap-window
  :desc "Toggle Locked"         "#"    #'toggle-window-dedicated))
#+END_SRC

**** Workspace

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("TAB" . "workspace")
   :desc "Switch to"     "." #'+workspace/my-switch-to
   :desc "Create"        "c" #'+workspace/new-named
   :desc "Rename"        "," #'+workspace/rename
   :desc "Clone"         "C" (λ!
                              (+workspace/new (format "Clone: %s" (+workspace-current-name)) t)
                              (message "Cloned current workspace %s" (+workspace-current-name)))
   :desc "Switch to last workspace" "0"   #'+workspace/other))
#+END_SRC

**** Yank

#+BEGIN_SRC elisp
(map!
  :leader
  (:prefix-map ("y" . "Yank")
    :desc "filename"                        "f" (λ! (copy-message (file-name-nondirectory buffer-file-name)))
    :desc "base"                            "b" (λ! (copy-message (file-name-base (or buffer-file-name dired-directory))))
    :desc "directory"                       "d" (λ! (copy-message (file-name-directory (or buffer-file-name dired-directory))))
    :desc "path"                            "p" (λ! (copy-message (file-name-directory (or buffer-file-name dired-directory))))
    :desc "relative to propject project"    "r" (λ! (copy-message (s-replace (projectile-project-root) "" (or buffer-file-name dired-directory))))))
#+END_SRC

*** Little Word Motion

#+BEGIN_SRC elisp
(defun load-evil-camel-case-motion ()
  (require 'evil-little-word)
  (define-key evil-normal-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-normal-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "i M-w") 'evil-inner-little-word))

(after! rjsx-mode
  (load-evil-camel-case-motion))

(after! reason-mode
  (load-evil-camel-case-motion))

(after! js2-mode
  (load-evil-camel-case-motion))
#+END_SRC

*** Package (Local-Leader) Bindings

Pacakge/Mode specific bindings

**** Eshell

#+BEGIN_SRC elisp
(defun floscr|+eshell|init-keymap ()
  "Setup additional custom eshell keybindings to already existing doom bindings. This must be done in a hook because eshell-mode
redefines its keys every time `eshell-mode' is enabled."
  (map! :map eshell-mode-map
        :in "C-p"         #'eshell-previous-input
        :in "C-n"         #'eshell-next-input

        :in "C-k"         #'evil-window-up
        :in "C-j"         #'evil-window-down
        :in "C-h"         #'evil-window-left
        :in "C-l"         #'evil-window-right

        :localleader "l"  #'eshell/clear))

(add-hook 'eshell-first-time-mode-hook #'floscr|+eshell|init-keymap)
#+END_SRC

**** Elisp

#+BEGIN_SRC elisp
(map! :map emacs-lisp-mode-map
      ;; Rearrange Sexps
      :n "s-k"   (λ! (sp-transpose-sexp)
                     (evil-previous-line))
      :n "s-j"   (λ! (sp-push-hybrid-sexp)
                     (evil-next-line))

      ;; Eval Buffer
      :n "s-r" #'eval-buffer

      ;; Slurp and barf
      :n "g]"  #'sp-slurp-hybrid-sexp
      :n "g["  #'sp-forward-barf-sexp

      :localleader
      :desc "Symex Mode"  "s" #'symex-mode-interface
      :desc "Raise sexp"  "<" #'raise-sexp
      :desc "Barf Sexp"   ">" #'barf-sexp)
#+END_SRC

**** Bash

#+BEGIN_SRC elisp
(map! :map sh-mode-map
      :localleader
      :desc "Eval Region"  "e" #'sh-execute-region
      :desc "Eval Region"  "E" #'executable-interpret)
#+END_SRC

**** Git

#+BEGIN_SRC elisp
(map! :map magit-mode-map
      :localleader
      :desc "Toggle Magit Buffer Lock" "#" #'magit-toggle-buffer-lock)
#+END_SRC

**** Reasonml

#+BEGIN_SRC elisp
(map! :map reason-mode-map
      :localleader
      :desc "Eval Region"  "r" #'refmt)
#+END_SRC

**** Mail

#+BEGIN_SRC elisp
(map! :map (mu4e-view-mode-map mu4e-headers-mode-map)
      :localleader
      :g "x" (λ!
              (require 'org-mu4e)
              (org-mu4e-store-and-capture)))
#+END_SRC

*** Minibuffer Bindings
**** Copy and Paste from the minibuffer

Since the minibuffer has no evil mode, i've got these bindings to help out:
- ~M-c~: Copy the minibuffer line
- ~M-v~: Paste from clippboard to minibuffer (Same as ~C-r 0~)
         This also removes trailng newlines

#+BEGIN_SRC elisp
(defun evil-get-register-string (REGISTER)
  "Get evil-register pure text content
Registers can be selected with ?letter
E.g.: ?* -> Clipboard Contents"
  (evil-vector-to-string (evil-get-register REGISTER)))

(defun paste-evil-register-clipboard-pruned ()
  "Paste the current clipboard pruned from newlines"
  (interactive)
  (insert (s-trim (shell-command-to-string "pbpaste")))
  (doom/forward-to-last-non-comment-or-eol))

(defun copy-minibuffer-line ()
  "Copies the minibuffer content to the clipboard"
  (interactive)
  (save-excursion
    (doom/forward-to-last-non-comment-or-eol)
    (set-mark-command nil)
    (doom/backward-to-bol-or-indent)
    (kill-ring-save (mark) (point))))

(defun setup-minibuffer ()
  "Set up keybindings for the minibuffer"
  (local-set-key (kbd "s-v") 'paste-evil-register-clipboard-pruned)
  (local-set-key (kbd "s-c") 'copy-minibuffer-line))

(add-hook 'minibuffer-setup-hook 'setup-minibuffer)

;; (define-key! :keymaps +default-minibuffer-maps
;;   "C-w" 'sp-backward-delete-word)
#+END_SRC
